<script>
var CONFIG = {
	maxNext: 3,
	maxLatest: 15,
	
	animes: [
		{
			name: 'Bleach', lastEp: 355,
			filters: [ 'Horrible', '720p' ]
		},
		{
			name: 'Mirai Nikki', lastEp: 13,
			filters: [ 'GotWoot', '8-bit' ]
		},
		{
			name: 'Amagami SS Plus', lastEp: 2,
			filters: [ 'UTW', '720p' ]
		},
		{
			name: 'Ano Natsu de Matteru', lastEp: 1,
			filters: [ 'Horrible', '720p' ]
		},
		{
			name: 'Another', lastEp: 1
		},
		{
			name: 'Ben-to', lastEp: 12,
			filters: [ 'gg' ]
		},
		{
			name: 'Boku Ha Tomodachi Ga Sukunai', lastEp: 12
		},
		{
			name: 'Brave10', lastEp: 1
		},
		{
			name: 'Daily Lives of High School Boys', lastEp: 1
		},
		{
			name: 'Kimi to Boku', lastEp: 13,
			filters: [
				[ 'CTSS' ],
				[ 'sage' ]
			]
		},
		{
			name: 'Nisemonogatari', lastEp: 1,
			filters: 'Horrible'
		}
	]
};

function containsAll(str, r) {
	if (typeof(r) === 'string')
		return str.indexOf(r) >= 0;
		
	for (var i = 0; i < r.length; i++) {
		if (str.indexOf(r[i]) < 0)
			return false;
	}

	return true;
}

/*
Valid filters:
str => must contain str
[ str1, str2 ] => must contain both str1 and str2
[ [ str1, str2 ], [ str3, str4 ] ] => Must contain str1 AND str2 OR str3 AND str4
*/
function filterMatches(str, r) {
	if (typeof(r) === 'string' || typeof(r[0]) === 'string')
		return containsAll(str, r);
		
	for (var i = 0; i < r.length; i++) {
		if (containsAll(str, r[i]))
			return true;
	}
	
	return false;
};

function toggleExpand(el) {
	if (el.className.indexOf('collapsed') >= 0)
		el.className = el.className.replace(/collapsed/g, '');
	else
		el.className += 'collapsed';
};


function isNextEpisode(next, anime) {
	var nextEp = anime.lastEp + 1;
	
	if (isNaN(next.ep)) {
		if (next.title.indexOf(nextEp) < 0) {
			return false;
		}
	} else if (next.ep !== nextEp) {
		return false;
	}
	
	return (!anime.filters || filterMatches(next.title, anime.filters));
};

function parseAnime(item, exp) {
	var title = item.querySelector('title').firstChild.nodeValue.replace(/_/g, ' '),
	// var title = item,
		next = {
			title: title,
			xml: item,
			group: null,
			ep: Number.NaN
		};
	
	var idx = title.indexOf(exp.name);
	if (idx >= 0) {
		// group: [groupName] => remove [, ] and any whitespaces
		var group = title.substring(0, idx).replace(/[\[\]\s]/g, '');
		next.group = group;
		
		idx += exp.name.length;
		var epEnd = title.indexOf('[', idx);
		if (epEnd > 0) {
			var ep = title.substring(idx, epEnd).replace(/-/g, '');
			next.ep = parseInt(ep, 10);
		}
	}
	
	return next;
};

function insertSorted(title, root, el) {
	for (var i = 0; i < root.childNodes.length; i++) {
		var c = root.childNodes[i];
		if (c.nodeType === 1 && c.className.indexOf('anime') >= 0) {
			if (c.querySelector('.title').firstChild.nodeValue > title) {
				root.insertBefore(el, c);
				return;
			}
		}
	}		
	root.appendChild(el);
};

function removeChilds(el) {
	while (el.firstChild)
		el.removeChild(el.firstChild);
};

function downloadTorrent(e) {
	var url = e.target.getAttribute('href');
	chrome.tabs.update(null, { url: url });
};

function appendLink(el, anime) {
	var a = document.createElement('a'),
		url = anime.xml.querySelector('link').firstChild.nodeValue;
	
	a.className = 'torrent';
	a.innerText = anime.title;
	a.setAttribute('href', url);
	a.addEventListener('click', downloadTorrent, true);
				
	el.appendChild(a);
};

function pullTorrents(anime, el) {
	var req = new XMLHttpRequest();
	req.open('GET', 'http://www.nyaa.eu/?page=rss&cats=1_37&term=' + anime.name, true);
	req.onload = function() {	
		// console.log(req.responseXML);
		var latestEl = el.querySelector('.latest'),
			epEl = el.querySelector('.next'),
			items = req.responseXML.getElementsByTagName('item');
			
		el.className = el.className.replace(/loading/g, '');
			
		for (var i = 0; i < items.length && latestEl.childNodes.length < CONFIG.maxLatest; i++) {
			var next = parseAnime(items[i], anime);
			
			if (isNextEpisode(next, anime) && epEl.childNodes.length < CONFIG.maxNext) {
				appendLink(epEl, next);
			}
			
			appendLink(latestEl, next);
		}
	};
	req.send(null);
};

window.onload = function() {
	var root = document.getElementById('animes'),
		prot = document.getElementById('prototype');
		
	for (var i = 0; i < CONFIG.animes.length; i++) {
		var el = prot.cloneNode(true),
			anime = CONFIG.animes[i];
			
		el.removeAttribute('id');
		el.querySelector('.title').innerText = anime.name;
		
		// cleanup prototype stuff
		removeChilds(el.querySelector('.latest'));
		removeChilds(el.querySelector('.next'));
		
		insertSorted(anime.name, root, el);
		
		pullTorrents(anime, el);
	}
};
</script>
<style>
body {
	min-width: 600px;
	overflow-x: hidden;
}

.anime.loading {
	color: #ccc;
}
.anime {
	border-bottom: 1px dashed #000;
	margin-bottom: 8px;
}
.anime:last-child {
	border-bottom: none;
}

.title {
	font-weight: bold;
}

.downloads .latest:before {
	content: 'Latest';
}
.downloads .next:before {
	content: 'Next';
}

.torrent {
	margin-left: 8px;
	text-decoration: none;
}

.torrent:hover {
	text-decoration: underline;
}

.collapsed .torrent {
	display: none;
}

#prototype {
	display: none;
}
</style>

<body>
	<div id="prototype" class="anime loading">
		<div class="title">Whatever</div>
		<div class="downloads">
			<div class="category next">				
				<a class="torrent" href="http://test">test</a>
				<a class="torrent" href="http://test">test2</a>
			</div>
			<div class="category latest collapsed" onclick="toggleExpand(this);">				
				<a class="torrent" href="http://test">test</a>
				<a class="torrent" href="http://test">test2</a>
			</div>
		</div>
	</div>

	<div id="animes"></div>
</body>